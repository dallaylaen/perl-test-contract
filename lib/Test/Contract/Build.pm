package Test::Contract::Build;

use strict;
use warnings;
our $VERSION = 0.0205;

=head1 NAME

Test::Contract::Build - tool for extending Test::Contract suite

=head1 DESCRIPTION

Unfortunately, extending L<Test::Contract> is not completely straightforward.

In order to create a new test function, one needs to:

=over

=item * provide a check function that returns a false value on success
and a brief description of the problem on failure
(e.g. C<"$got != $expected">);

=item * build an exportable wrapper around it that would talk to
the most up-to-date L<Test::Contract::Engine> instance;

=item * add a method with the same name to L<Test::Contract::Engine>
so that object-oriented and functional interfaces
are as close to each other as possible.

=back

The first task still has to be done by a programmer (you),
but the other two can be more or less automated.
Hence this module.

=head1 SINOPSYS

Extending the test suite goes as follows:

    package My::Package;
    use Test::Contract::Build;
    use parent qw(Exporter);

    build_refute is_everything => sub {
        return if $_[0] == 42;
        return "$_[0] is not answer to life, universe, abd everything";
    }, export => 1, args => 1;

    1;

The function provided to builder must return a false value if everything is ok,
or some details (but generally any true value) if not.

This call will create a prototyped function is_everything(...) in the calling
package, with C<args> positional parameters and an optional human-readable
message. (Think "ok 1", "ok 1 'test passed'").

=head1 FUNCTIONS

All functions are exportable.

=cut

use Carp;
use Scalar::Util qw(weaken blessed set_prototype looks_like_number refaddr);
use parent qw(Exporter);
our @EXPORT = qw(build_refute contract_engine to_scalar);
our @EXPORT_OK = qw(contract_engine_push contract_engine_cleanup);

=head2 build_refute name => CODE, %options

Create a function in calling package and a method in L<Test::Contract::Engine>.
As a side effect, Test::Contract's internals are added to the caller's
C<@CARP_NOT> array so that carp/croak points to actual outside usage.

Options may include:

=over

=item * export => 1

=item * export_ok => 1

=item * no_create => 1 - if you don't want a function to be autogenerated.
See L<Test::Contract::Exception> for example (custom prototyped functions).

=back

A lot of magic happens inside this function.

=cut

my %Backend;
my %Carp_not;
my $trash_can = __PACKAGE__."::generated::For::Cover::To::See";

sub build_refute(@) { ## no critic # Moose-like DSL for the win!
    my ($name, $cond, %opt) = @_;

    my $class = "Test::Contract::Engine";

    if (my $backend = ( $class->can($name) ? $class : $Backend{$name} ) ) {
        croak "build_refute(): '$name' already registered by $backend";
    };

    my $target = $opt{target} || caller;

    my $nargs = $opt{args} || 0;
    $nargs = 9**9**9 if $opt{no_pop};

    my $method  = sub {
        my $self = shift;
        my $message; $message = pop unless @_ <= $nargs;

        return $self->refute( scalar $cond->(@_), $message );
    };
    my $wrapper = sub {
        my $message; $message = pop unless @_ <= $nargs;
        return contract_engine()->refute( scalar $cond->(@_), $message );
    };
    # '&' for set_proto to work on a scalar, not {CODE;}
    &set_prototype( $wrapper, '$' x $opt{args} . ';$' )
        if $opt{args};

    $Backend{$name}   = $target; # just for the record
    my $todo_carp_not = !$Carp_not{ $target }++;
    my $todo_create   = !$opt{no_create};
    my $export        = $opt{export} ? "EXPORT" : $opt{export_ok} ? "EXPORT_OK" : "";

    # Magic below, beware!
    no strict 'refs'; ## no critic # really need magic here

    # set up method for OO interface
    *{ $class."::$name" } = $method;

    # FIXME UGLY HACK - somehow it makes Devel::Cover see the code in report
    *{ $trash_can."::$name" } = $cond;

    if ($todo_create) {
        *{ $target."::$name" } = $wrapper;
        push @{ $target."::".$export }, $name
            if $export;
    };
    if ($todo_carp_not) {
        no warnings 'once';
        push @{ $target."::CARP_NOT" }, __PACKAGE__, $class;
    };

    # magic ends here

    return 1;
};

=head2 contract_engine

Returns current default engine, dies if none right now.

=cut

my @stack;

sub contract_engine() { ## no critic
    @stack or croak [caller]->[3]."(): Not currently testing anything";
    return $stack[-1];
};

=head2 contract_engine_push( $contract )

Make C<$contract> the default engine until it's detroyed, or done_testing is
called. This is useful for stuff like subtests.
As the name suggests, may be called multiple times, creating a stack.

C<$contract> must be a L<Test::Contract::Engine> descendant.

If C<$contract> goes out of scope, it is automatically removed from the stack.
(See C<weaken> in L<Scalar::Util>).

Maybe it's better to avoid this call in favor of safer C<contract> in
sibling modules, unless there's a reason.

Not exported by default.

=cut

sub contract_engine_push {
    my $eng = shift;
    blessed $eng and $eng->isa( "Test::Contract::Engine" )
        or croak( "contract_engine_push(): won't load anything but Test::Contract::Engine" );
    push @stack, $eng;
    weaken $stack[-1];
    return scalar @stack;
};

=head2 contract_engine_cleanup

Remove all finished contracts from engine stack.
This is called by both C<done_testing> and contract's destructor.

Maybe it's better to avoid this call in favor of safer C<contract> in
sibling modules, unless there's a reason.

Not exported by default.

=cut

sub contract_engine_cleanup {
    while (@stack and (!$stack[-1] or $stack[-1]->get_done)) {
        pop @stack;
    };
    return scalar @stack;
};

=head2 to_scalar ( [] || {} || "string" || undef )

Convert an unknown data type to a human-readable string.

Hashes/arrays are only penetrated 1 level deep.

undef is returned as C<(undef)> so it can't be confused with other types.

Strings are quoted unless numeric.

Refs returned as "My::Module/1a2c3f

=cut

my %replace = ( "\n" => "n", "\\" => "\\", '"' => '"', "\0" => "0", "\t" => "t" );
sub to_scalar {
    my ($data, $depth) = @_;
    $depth = 1 unless defined $depth;

    return '(undef)' unless defined $data;
    if (!ref $data) {
        return $data if looks_like_number($data);
        $data =~ s/([\0"\n\t\\])/\\$replace{$1}/g;
        $data =~ s/([^\x20-\xFF])/sprintf "\\x%02x", ord $1/ge;
        return "\"$data\"";
    };
    if ($depth) {
        if (UNIVERSAL::isa($data, 'ARRAY')) {
            return (ref $data eq 'ARRAY' ? '' : ref $data)
                ."[".join(", ", map { to_scalar($_, $depth-1) } @$data )."]";
        };
        if (UNIVERSAL::isa($data, 'HASH')) {
            return (ref $data eq 'HASH' ? '' : ref $data)
            . "{".join(", ", map {
                 to_scalar($_, 0) .":".to_scalar( $data->{$_}, $depth-1 );
            } sort keys %$data )."}";
        };
    };
    return sprintf "%s/%x", ref $data, refaddr $data;
};

=head2 contract_engine_init

Start default testing engine if run from within a test script.
The engine will be created just once and put on top of the stack.

This should be called from custom modules to be able to interact
with Test::More.

=cut

my $main_engine;
my $main_pid;

sub contract_engine_init {
    return if $main_engine;

    if (Test::Builder->can("ok")) {
        require Test::Contract::Engine::More;
        $main_engine = Test::Contract::Engine::More->new;
    } else {
        require Test::Contract::Engine::TAP;
        $main_engine = Test::Contract::Engine::TAP->new;
    };
    $main_engine->start_testing;
    $main_pid = $$;
};

END {
    if ($main_engine and $main_engine->isa("Test::Contract::Engine::TAP") and $main_pid == $$) {
        carp "Test::More loaded by accident, but Test::Refute is not in compat mode!"
            if Test::Builder->can("ok");
        if ($main_engine->get_count) {
            croak "[$$] done_testing was not seen"
                unless $main_engine->get_plan;

            $main_engine->done_testing
                unless $main_engine->get_done;

            my $ret = $main_engine->get_error_count;
            $ret = 100 if $ret > 100;
            $? = $ret;
        }
        elsif ($main_engine->get_skipped) {
            $main_engine->done_testing
                unless $main_engine->get_done;
        };
    };
};

1;
